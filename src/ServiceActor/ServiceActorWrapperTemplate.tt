<#@ template language="C#" #>
<#@ assembly name="System.Core" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ import namespace="System.Threading.Tasks" #>
<#@ import namespace="ServiceActor" #>
using System;
using System.Linq;
using System.Threading;
using System.Threading.Tasks;
using ServiceActor;

public class <#= TypeToWrapName #>AsyncActorWrapper : <#= TypeToWrapFullName #>, ServiceActor.IServiceActorWrapper
{
    private readonly <#= TypeToWrapFullName #> _objectToWrap;
    private readonly string _typeOfObjectToWrap;

    public object WrappedObject { get => _objectToWrap; }
    public ActionQueue ActionQueue { get; }

    public <#= TypeToWrapName #>AsyncActorWrapper(<#= TypeToWrapFullName #> objectToWrap, string typeOfObjectToWrap, ServiceActor.ActionQueue actionQueue)
    {
        _objectToWrap = objectToWrap ?? throw new ArgumentNullException(nameof(objectToWrap));
        _typeOfObjectToWrap = typeOfObjectToWrap ?? throw new ArgumentNullException(nameof(typeOfObjectToWrap));
        ActionQueue = actionQueue ?? throw new ArgumentNullException(nameof(actionQueue));
    }

    <# foreach (var property in GetProperties()) { #>
    public <#= property.PropertyType.GetTypeReferenceCode() #> <#= property.Name #>
    {
        <# if (property.CanRead) { #>
        get
        {
            <# if (PropertyGetAllowsConcurrentAccess(property)) { #>

            return _objectToWrap.<#= property.Name #>;

            <# } else { #>

            <#= property.PropertyType.GetTypeReferenceCode() #> res = default;
            var executedEvent = new AutoResetEvent(false);
            Exception exceptionThrown = null;
            ActionQueue.Enqueue(this, _typeOfObjectToWrap, () =>
            {
                try
                {
                    res = _objectToWrap.<#= property.Name #>;
                }
                catch (Exception ex)
                {
                    exceptionThrown = ex;
                }

                executedEvent.Set();
            }, <#= KeepAsyncContext(property) ? "true" : "false" #>);

            executedEvent.WaitOne();

            if (exceptionThrown != null)
                throw exceptionThrown;

            if (ServiceRef.TryGetPendingOperation(_objectToWrap, out var pendingOperation))
            {
                pendingOperation.WaitForCompletion();
                res = ((IPendingOperation<<#= property.PropertyType.GetTypeReferenceCode() #>>)pendingOperation)
                    .GetResultFunction()
                    .Invoke();
            }

            return res;

            <# } #>
        }
        <# } #>
        <# if (property.CanWrite) { #>
        set
        {
            <# if (PropertySetAllowsConcurrentAccess(property)) { #>

            _objectToWrap.<#= property.Name #> = value;

            if (ServiceRef.TryGetPendingOperation(_objectToWrap, out var pendingOperation))
            {
                throw new InvalidOperationException("Pending operations are not supported for pure set properties: use BlockCaller attribute instead");
            }

            <# } else { #>

                <# if (BlockCaller(property)) { #>

                var executedEvent = new AutoResetEvent(false);
                Exception exceptionThrown = null;

                ActionQueue.Enqueue(this, _typeOfObjectToWrap, () =>
                {
                    try
                    {
                        _objectToWrap.<#= property.Name #> = value;
                    }
                    catch (Exception ex)
                    {
                        exceptionThrown = ex;
                    }

                    executedEvent.Set();
                }, <#= KeepAsyncContext(property) ? "true" : "false" #>);

                executedEvent.WaitOne();

                if (exceptionThrown != null)
                    throw exceptionThrown;

                if (ServiceRef.TryGetPendingOperation(_objectToWrap, out var pendingOperation))
                {
                    pendingOperation.WaitForCompletion();
                }

                <# } else { #>

                ActionQueue.Enqueue(this, _typeOfObjectToWrap, () =>
                {
                    _objectToWrap.<#= property.Name #> = value;
                    if (ServiceRef.TryGetPendingOperation(_objectToWrap, out var pendingOperation))
                    {
                        throw new InvalidOperationException("Pending operations are not supported for pure set properties: use BlockCaller attribute instead");
                    }

                }, <#= KeepAsyncContext(property) ? "true" : "false" #>);

                <# } #>

            <# } #>
        }
        <# } #>
    }
	<# } #>

    <# foreach (var method in GetMethods()) { #>
    
        <# if (method.Info.ReturnType == typeof(void)) { #>
        public <#= method.Info.GetMethodDeclarationCode() #>
        {
            <# if (MethodAllowsConcurrentAccess(method)) { #>

            _objectToWrap.<#= method.Info.GetMethodInvocationCode() #>;

            if (ServiceRef.TryGetPendingOperation(_objectToWrap, out var pendingOperation))
            {
                throw new InvalidOperationException("Pending operations are not supported for pure void methods: use BlockCaller attribute instead");
            }

            <# } else { #>

                <# if (BlockCaller(method)) { #>

                var executedEvent = new AutoResetEvent(false);
                Exception exceptionThrown = null;
                ActionQueue.Enqueue(this, _typeOfObjectToWrap, () =>
                {
                    try
                    {
                        _objectToWrap.<#= method.Info.GetMethodInvocationCode() #>;
                    }
                    catch (Exception ex)
                    {
                        exceptionThrown = ex;
                    }
                    executedEvent.Set();
                }, <#= KeepAsyncContext(method) ? "true" : "false" #>);

                executedEvent.WaitOne();

                if (exceptionThrown != null)
                    throw exceptionThrown;

                if (ServiceRef.TryGetPendingOperation(_objectToWrap, out var pendingOperation))
                {
                    pendingOperation.WaitForCompletion();
                }

                <# } else { #>

                ActionQueue.Enqueue(this, _typeOfObjectToWrap, () =>
                {
                    _objectToWrap.<#= method.Info.GetMethodInvocationCode() #>;
                    
                    if (ServiceRef.TryGetPendingOperation(_objectToWrap, out var pendingOperation))
                    {
                        throw new InvalidOperationException("Pending operations are not supported for pure void methods: use the BlockCaller attribute instead");
                    }

                }, <#= KeepAsyncContext(method) ? "true" : "false" #>);

                <# } #>

            <# } #>
        }
        <# } else if (method.Info.ReturnType == typeof(Task)) { #>
        public async <#= method.Info.GetMethodDeclarationCode() #>
        {
            <# if (MethodAllowsConcurrentAccess(method)) { #>

            await _objectToWrap.<#= method.Info.GetMethodInvocationCode() #>;

            if (ServiceRef.TryGetPendingOperation(_objectToWrap, out var pendingOperation))
            {
                throw new InvalidOperationException("Pending operations are not supported for pure Task methods: use the BlockCaller attribute instead");
            }

            <# } else { #>

            var executedEvent = new Nito.AsyncEx.AsyncAutoResetEvent(false);
            Exception exceptionThrown = null;
            ActionQueue.Enqueue(this, _typeOfObjectToWrap, async () =>
            {
                try
                {
                    await _objectToWrap.<#= method.Info.GetMethodInvocationCode() #>;
                }
                catch (Exception ex)
                {
                    exceptionThrown = ex;
                }
                executedEvent.Set();
            }, <#= KeepAsyncContext(method) ? "true" : "false" #>);

            await executedEvent.WaitAsync();

            if (exceptionThrown != null)
                throw exceptionThrown;

            if (ServiceRef.TryGetPendingOperation(_objectToWrap, out var pendingOperation))
            {
                pendingOperation.WaitForCompletion();
            }

            <# } #>

        }
        <# } else if (method.Info.ReturnType.BaseType == typeof(Task)) { #>
        public async <#= method.Info.GetMethodDeclarationCode() #>
        {
            <# if (MethodAllowsConcurrentAccess(method)) { #>

            var res = await _objectToWrap.<#= method.Info.GetMethodInvocationCode() #>;
            
            if (ServiceRef.TryGetPendingOperation(_objectToWrap, out var pendingOperation))
            {
                throw new InvalidOperationException("Pending operations are not supported for pure Task methods: use the BlockCaller attribute instead");
            }

            return res;

            <# } else { #>

            <#= method.Info.ReturnType.GetGenericArguments()[0].GetTypeReferenceCode() #> res = default;
            var executedEvent = new Nito.AsyncEx.AsyncAutoResetEvent(false);
            Exception exceptionThrown = null;
            ActionQueue.Enqueue(this, _typeOfObjectToWrap, async () =>
            {
                try
                {
                    res = await _objectToWrap.<#= method.Info.GetMethodInvocationCode() #>;
                }
                catch (Exception ex)
                {
                    exceptionThrown = ex;
                }
                executedEvent.Set();
            }, <#= KeepAsyncContext(method) ? "true" : "false" #>);

            await executedEvent.WaitAsync();

            if (exceptionThrown != null)
                throw exceptionThrown;

            if (ServiceRef.TryGetPendingOperation(_objectToWrap, out var pendingOperation))
            {
                pendingOperation.WaitForCompletion();
                res = await ((IPendingOperation<Task<<#= method.Info.ReturnType.GetGenericArguments()[0].GetTypeReferenceCode() #>>>)pendingOperation)
                    .GetResultFunction()
                    .Invoke();
            }

            return res;

            <# } #>
        }
        <# } else { #>
        public <#= method.Info.GetMethodDeclarationCode() #>
        {
            <# if (MethodAllowsConcurrentAccess(method)) { #>

            var res = _objectToWrap.<#= method.Info.GetMethodInvocationCode() #>
            
            if (ServiceRef.TryGetPendingOperation(_objectToWrap, out var pendingOperation))
            {
                throw new InvalidOperationException("Pending operations are not supported for pure methods: use the BlockCaller attribute instead");
            }

            return res;
            <# } else { #>

            <#= method.Info.ReturnType.GetTypeReferenceCode() #> res = default;
            var executedEvent = new AutoResetEvent(false);
            Exception exceptionThrown = null;
            ActionQueue.Enqueue(this, _typeOfObjectToWrap, () =>
            {
                try
                {
                    res = _objectToWrap.<#= method.Info.GetMethodInvocationCode() #>;
                }
                catch (Exception ex)
                {
                    exceptionThrown = ex;
                }
                executedEvent.Set();
            }, <#= KeepAsyncContext(method) ? "true" : "false" #>);

            executedEvent.WaitOne();

            if (exceptionThrown != null)
                throw exceptionThrown;

            if (ServiceRef.TryGetPendingOperation(_objectToWrap, out var pendingOperation))
            {
                pendingOperation.WaitForCompletion();
                res = ((IPendingOperation<<#= method.Info.ReturnType.GetTypeReferenceCode() #>>)pendingOperation)
                    .GetResultFunction()
                    .Invoke();
            }

            return res;

            <# } #>

        }
        <# } #>

    <# } #>
    
}

return new <#= TypeToWrapName #>AsyncActorWrapper((<#= TypeToWrapFullName #>)ObjectToWrap, "<#= TypeToWrapFullName #>", ActionQueueToShare);